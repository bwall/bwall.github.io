<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on @botnet_hunter&#39;s blog</title>
    <link>https://bwall.github.io/tags/python/</link>
    <description>Recent content in Python on @botnet_hunter&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© 2015 Copyright Brian Wallace</copyright>
    <lastBuildDate>Sun, 11 Oct 2015 15:41:07 -0700</lastBuildDate>
    <atom:link href="https://bwall.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Detecting shellcode over the network with scapy and libemu</title>
      <link>https://bwall.github.io/libemu-scapy-for-shellcode-on-the-network/</link>
      <pubDate>Sun, 11 Oct 2015 15:41:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/libemu-scapy-for-shellcode-on-the-network/</guid>
      <description>

&lt;p&gt;In this blog post, I will describe a method of using libemu along with scapy in order to detect shellcode being sent across the network in unencrypted channels.  This method would not be particularly reasonable for large networks without a significant amount of computing power.  On the other hand, for semi-automated analysis, or even integration into something like Cuckoo Sandbox, it may be quite useful.&lt;/p&gt;

&lt;p&gt;While this proof of concept is currently functional, it would take some work on the project&amp;rsquo;s dependencies in order for me to consider the project a success.  I have not yet decided if I plan on dedicating significant time to resolving issues in the related projects.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;network-detection-of-shellcode:f0f2ac46c551efb82181805b8d37429b&#34;&gt;Network Detection of Shellcode&lt;/h1&gt;

&lt;p&gt;In order to detect this shellcode, we need a few major components.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Method to detect shellcode in a buffer&lt;/li&gt;
&lt;li&gt;Method to acquire network packets&lt;/li&gt;
&lt;li&gt;Method to assembly socket communication over the network&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the first requirement, we simply use libemu.&lt;/p&gt;

&lt;p&gt;For the remaining requirements, we use scapy and some additional Python code.&lt;/p&gt;

&lt;h2 id=&#34;libemu:f0f2ac46c551efb82181805b8d37429b&#34;&gt;libemu&lt;/h2&gt;

&lt;p&gt;Libemu is a library for detecting and emulating shellcode, allowing for some automated analysis of shellcode.  Unfortunately, it does not appear to be under active development, and getting up to date source code is currently alluding me. It also appears to have a few bugs, some of which make it less viable for integration into network perimeter defenses.&lt;/p&gt;

&lt;p&gt;Along with it being difficult to locate the source, the current libemu interfaces to libemu in Python both seem to have some issues.  While both python-libemu and pylibemu are very useful, python-libemu fails to implement many of the features of libemu, and pylibemu currently has some issues which seriously impact memory usage.&lt;/p&gt;

&lt;p&gt;I have found that even via the Python interfaces, an arbitrary buffer supplied to libemu for processing can lead to a floating point error, which will crash the process.  This is one reason I do not suggest running this in production environments, or on large enterprise networks.&lt;/p&gt;

&lt;p&gt;For our purposes, we&amp;rsquo;ll use python-libemu, installed on Ubuntu with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python-libemu
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scapy:f0f2ac46c551efb82181805b8d37429b&#34;&gt;scapy&lt;/h2&gt;

&lt;p&gt;Scapy is well known as a raw networking library for Python, and being pretty awesome.  I&amp;rsquo;m not going to spend time covering Scapy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pip install scapy
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis:f0f2ac46c551efb82181805b8d37429b&#34;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;In order to scan over these packets in a similar way that the attacker would send them, we need to create the socket streams.  More specifically, we need to look at each direction of communication.  Additionally, we don&amp;rsquo;t want all of every stream in memory at the same time, so we use a LRUCache (from cachetools) to keep the most recent streams in memory, and use a memory buffering technique called a sliding window.&lt;/p&gt;

&lt;p&gt;In a sliding window, we set the max amount of memory we want to use per stream, then as we get new data, we append the new data, then cut off bytes in the beginning of our buffer until it is smaller than our max buffer size.  This way we can look at all the data, and avoid simply looking at each packet.&lt;/p&gt;

&lt;p&gt;For each new packet we get, we scan the sliding window buffer with libemu.  If libemu detects shellcode, we print the offset and the quad (ip:port-ip:port).&lt;/p&gt;

&lt;h1 id=&#34;code:f0f2ac46c551efb82181805b8d37429b&#34;&gt;Code&lt;/h1&gt;

&lt;p&gt;I will not update the code in this blog post, but if I need to, I will update the code in the following gist.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/bwall/9cba618eacedc68c656b&#34;&gt;Network Shellcode Detection Proof of Concept&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the proof of concept, the shellcode detection is being done across every thread on the local computer.  This is done because libemu scanning scan be quite CPU intensive and slow.&lt;/p&gt;

&lt;p&gt;The PoC requires the following commands before being installed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python-libemu python-pip
sudo pip install scapy
sudo pip install cachetools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python2
import logging

logging.getLogger(&amp;quot;scapy.runtime&amp;quot;).setLevel(logging.ERROR)
from multiprocessing.pool import ThreadPool
from multiprocessing import cpu_count
import libemu
from cachetools import LRUCache
from scapy.layers.all import TCP, UDP, Raw
from scapy.all import sniff
import Queue


stream_cache = LRUCache(1024)
BUFFER_SIZE = 1024 * 1024
USE_SLIDING_WINDOW = True
THREADS = cpu_count()
thread_pool = None


class LimitedPool(ThreadPool):
    def __init__(self, processes=None, initializer=None, initargs=(), max_queue_size=10000):
        self._max_queue_size = max_queue_size
        ThreadPool.__init__(self, processes, initializer, initargs)

    def _setup_queues(self):
        self._inqueue = Queue.Queue(self._max_queue_size)
        self._outqueue = Queue.Queue()
        self._quick_put = self._inqueue.put
        self._quick_get = self._outqueue.get


def generate_key(packet):
    k = &amp;quot;{0}:{1}-{2}:{3}&amp;quot;.format(packet.payload.src, packet.payload.payload.sport, packet.payload.dst, packet.payload.payload.dport)
    if packet.haslayer(TCP):
        return &amp;quot;tcp://{0}&amp;quot;.format(k)
    if packet.haslayer(UDP):
        return &amp;quot;udp://{0}&amp;quot;.format(k)


def test_for_shellcode((key, packet, file_path)):
    e = libemu.Emulator()
    r = e.test(packet)
    if r is not None and r &amp;gt;= 0:
        logging.warning(&amp;quot;{2}: {0} - {1}&amp;quot;.format(key, {&amp;quot;offset&amp;quot;: r}, file_path))


def process_packet(pkt, file_path):
    global thread_pool
    try:
        if pkt.haslayer(Raw) and len(pkt[Raw].original) &amp;gt; 0:
            k = generate_key(pkt)
            if USE_SLIDING_WINDOW:
                if k in stream_cache:
                    stream_cache[k] += pkt[Raw].original
                    stream_cache[k] = stream_cache[k][-BUFFER_SIZE:]
                else:
                    stream_cache[k] = pkt[Raw].original[-BUFFER_SIZE:]
                p = stream_cache[k]
            else:
                p = pkt[Raw].original

            #test_for_shellcode((k, p, file_path))
            thread_pool.apply_async(test_for_shellcode, [(k, p, file_path)])
    except KeyboardInterrupt:
        raise
    except:
        pass


if __name__ == &amp;quot;__main__&amp;quot;:
    logging.basicConfig(level=logging.DEBUG)
    from argparse import ArgumentParser

    parser = ArgumentParser(
        prog=__file__,
        description=&amp;quot;Proof of concept for shellcode identification in pcap or network&amp;quot;,
        version=&amp;quot;%(prog)s v0.0.1 by Brian Wallace (@botnet_hunter)&amp;quot;,
        epilog=&amp;quot;%(prog)s v0.0.1 by Brian Wallace (@botnet_hunter)&amp;quot;
    )
    parser.add_argument(&#39;path&#39;, metavar=&#39;path&#39;, type=str, nargs=&#39;*&#39;, default=None, help=&amp;quot;Paths to files to parse&amp;quot;)

    args = parser.parse_args()

    thread_pool = LimitedPool(processes=THREADS, max_queue_size=200)

    if args.path is None or len(args.path) == 0:
        print &amp;quot;Live sniffing&amp;quot;
        sniff(store=0, filter=&amp;quot;tcp or udp&amp;quot;, prn=lambda x: process_packet(x, &amp;quot;live&amp;quot;))
    else:
        for p in args.path:
            logging.warning(&amp;quot;Reading packets from {0}&amp;quot;.format(p))
            sniff(store=0, filter=&amp;quot;tcp or udp&amp;quot;, offline=p, prn=lambda x: process_packet(x, p))

    thread_pool.close()
    thread_pool.join()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/xMKiC7W.png&#34; alt=&#34;Network shellcode detection PoC working&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using bamfdetect in your own workflow</title>
      <link>https://bwall.github.io/bamfdetect/</link>
      <pubDate>Sun, 04 Oct 2015 17:59:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/bamfdetect/</guid>
      <description>

&lt;p&gt;When hunting botnets, whether they are custom developed or widely available, it can be helpful to statically extract configurations.  With this ability, an automated workflow can be developed to identify and track botnets at scale.  For this reason, I have developed &lt;a href=&#34;https://github.com/bwall/bamfdetect&#34;&gt;bamfdetect&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;bamfdetect:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;bamfdetect&lt;/h1&gt;

&lt;p&gt;bamfdetect is a tool which is designed to identify malware samples and statically extract their configuration information, such as the domain name of the command and control server.  It is capable of taking in a single file path, or a variety of file paths.  It supports searching inside of directories, archives, etc. Once it identifies files to process, it starts processing through groups of modules.  The modules are as follows.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preprocessors&lt;/li&gt;
&lt;li&gt;Bot Modules&lt;/li&gt;
&lt;li&gt;Postprocessors&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;preprocessors:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;Preprocessors&lt;/h2&gt;

&lt;p&gt;Preprocessors have the ability to modify the file before being processed by the bot modules.  This can be useful if files are somehow packed or obfuscated.  The only currently (at the time of this blog being written) implemented preprocessor is the UPX decompressor.  This identifies if the input file is UPX compressed, then uses the UPX binary installed on the system to decompress it.  This functionality may be removed in the near future.&lt;/p&gt;

&lt;p&gt;A planned preprocessor module is a reimplementation of the PHP decoder I have running &lt;a href=&#34;https://defense.ballastsecurity.net/decoding/index.php&#34;&gt;here&lt;/a&gt;.  This would deobfuscate PHP files being processed.&lt;/p&gt;

&lt;h2 id=&#34;bot-modules:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;Bot Modules&lt;/h2&gt;

&lt;p&gt;Bot modules are the heart of bamfdetect.  These modules are implemented in two portions, the identifier and the extractor.  The identifiers, all of which are currently Yara signatures, identify whether a file being analyzed is a bot supported by the bot module.  Since bot modules tend to focus on a single bot type or a family of very similar bots, this generally confirms that the module is likely capable of extracting the configuration.&lt;/p&gt;

&lt;p&gt;The configuration extraction is then done with Python code.  Configuration extraction can be very strict or very loose, depending on how reliably the configuration is stored in the malware.  Admitedly, in some cases, the configuration extraction methods have been implemented somewhat lazily, so false positives and improperly extracted configurations are possible.&lt;/p&gt;

&lt;h2 id=&#34;postprocessors:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;Postprocessors&lt;/h2&gt;

&lt;p&gt;The purpose of postprocessor modules are to run after a file has been identified by at least one module.  The postprocessor modules also have access to the extracted configuration information, so they can be acted upon.  The only currently included postprocessing module calculates hashes on the file that was processed.  I do have a few private postprocessing modules which I will mention shortly.&lt;/p&gt;

&lt;h1 id=&#34;workflow:edf56eff04a8abdbcf184973e6c4191b&#34;&gt;Workflow&lt;/h1&gt;

&lt;p&gt;bamfdetect is a wonderful component of my malware tracking workflow.  Clearly, I&amp;rsquo;m not about to give away all my secrets right now, but here is a sample workflow which can be done with bamfdetect.&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://bwall.github.io/images/bamfworkflow.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Bot tracking workflow&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Since bamfdetect has Yara signatures defined inside of it, these Yara signatures can be used in services such as VirusTotal Hunting in order to hunt for relevant samples.  One can very simply download all files that trigger VirusTotal Hunting, and then feed them into bamfdetect.  Files can also be fed in through a variety of other sources.&lt;/p&gt;

&lt;p&gt;In order to make use of this, we can create a postprocessing module for bamfdetect which will upload any command and control information to our botnet tracking system.  Since very few people utilize publicly available systems for this, the code below is very generic.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from BAMF_Detect.postprocessors.common import Postprocessor, Postprocessors
import httplib
import urllib
import json


def submit_c2(c2_uri, bot_type, source, api_key):
    try:
        params = urllib.urlencode({&#39;api_key&#39;: api_key, &#39;uri&#39;: c2_uri, &#39;bot_type&#39;: bot_type, &#39;source&#39;: source})
        headers = {&amp;quot;Content-type&amp;quot;: &amp;quot;application/x-www-form-urlencoded&amp;quot;, &amp;quot;Accept&amp;quot;: &amp;quot;text/plain&amp;quot;}
        conn = httplib.HTTPSConnection(&amp;quot;c2_tracking.example.com&amp;quot;)
        conn.request(&amp;quot;POST&amp;quot;, &amp;quot;/upload_c2&amp;quot;, params, headers)
        response = conn.getresponse()
        data = response.read()
        conn.close()
        return json.loads(data)
    except KeyboardInterrupt:
        raise
    except:
        pass


class SubmitPanel(Postprocessor):
    def __init__(self):
        Postprocessor.__init__(
            self,
            name=&amp;quot;Hashes&amp;quot;,
            author=&amp;quot;Brian Wallace (@botnet_hunter)&amp;quot;,
            date=&amp;quot;March 14th, 2015&amp;quot;,
            description=&amp;quot;Submits panel to C2 database&amp;quot;,
            references=&amp;quot;&amp;quot;,
            version=&amp;quot;1.0.0.0&amp;quot;
        )

    def _do_processing(self, file_data, config):
        if &amp;quot;information&amp;quot; in config:
            configuration = config[&amp;quot;information&amp;quot;]
            bot_type = config[&amp;quot;type&amp;quot;].lower()

            if &amp;quot;c2_uri&amp;quot; in configuration:
                # Simple bot setup
                submit_c2(configuration[&amp;quot;c2_uri&amp;quot;], bot_type, &amp;quot;bamfdetect&amp;quot;, &amp;quot;api-key&amp;quot;)
            elif &amp;quot;c2s&amp;quot; in configuration:
                for c in configuration[&amp;quot;c2s&amp;quot;]:
                    if &amp;quot;c2_uri&amp;quot; in c:
                        submit_c2(c[&amp;quot;c2_uri&amp;quot;], bot_type, &amp;quot;bamfdetect&amp;quot;, &amp;quot;api-key&amp;quot;)

        return {}, file_data

Postprocessors.add_postprocessor(SubmitPanel())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way, anytime we scan a file, the command and control information will be uploaded to c2_tracking.example.com to be automatically tracked.  This is one of the methods I use to feed my botnet tracking platform.&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://bwall.github.io/images/tracking.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Bot tracking panel&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;a href=&#34;https://gist.github.com/bwall/aa3bf86bd2f2396d6ef5&#34;&gt;Tracking panel source&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Extract Hosts</title>
      <link>https://bwall.github.io/extract-hosts/</link>
      <pubDate>Fri, 18 Apr 2014 10:19:07 -0700</pubDate>
      
      <guid>https://bwall.github.io/extract-hosts/</guid>
      <description>

&lt;p&gt;Recently, I have been trying to focus more on creating small but useful utilities.  The first of these tools to be posted publicly is &lt;a href=&#34;https://github.com/bwall/ExtractHosts&#34;&gt;Extract Hosts&lt;/a&gt;.  The purpose of this utility is to search for domain names and IP addresses in the supplied input.  The following is information posted to the readme on the project page.  You can download the 1.1.0 release of Extract Hosts &lt;a href=&#34;https://github.com/bwall/ExtractHosts/archive/v1.1.0.zip&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;extracthosts:8154605aecfea6ca754b3151f752e9f0&#34;&gt;ExtractHosts&lt;/h1&gt;

&lt;p&gt;Extracts hosts (IP/Hostnames) from files.  Hosts can be extracted from text files, PE, etc.  Any file that keeps the
host in plaintext without obscuring it, this should extract it.&lt;/p&gt;

&lt;p&gt;The name came about when polling random people on the street about the idea, and they responded, &amp;ldquo;eh?&amp;rdquo;.  With this installed,
all you need to type is &amp;lsquo;eh&amp;rsquo; to start pulling hosts from input.&lt;/p&gt;

&lt;h1 id=&#34;installation:8154605aecfea6ca754b3151f752e9f0&#34;&gt;Installation&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/bwall/ExtractHosts.git
cd ExtractHosts
sudo python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;examples:8154605aecfea6ca754b3151f752e9f0&#34;&gt;Examples&lt;/h1&gt;

&lt;p&gt;The following are just some example usages&lt;/p&gt;

&lt;h2 id=&#34;help:8154605aecfea6ca754b3151f752e9f0&#34;&gt;help&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;bwall@research:~$ eh -h
usage: /usr/local/bin/eh [-h] [-v] [-r] [-f] [-d] [-T] [path [path ...]]

Identifies and extracts domains and IPs from files

positional arguments:
  path                  Paths to files or directories to scan (if not
                        supplied, stdin is the file being read)

optional arguments:
  -h, --help            show this help message and exit
  -v, --version         show program&#39;s version number and exit
  -r, --recursive       Scan paths recursively
  -f, --show-files      Show file names along with results
  -d, --hide-duplicates
                        Hide duplicate results (hides per file when show-files
                        is enabled)
  -s, --strict          Stricter processing of domains
  -T, --test            Run some quick self tests

/usr/local/bin/eh v1.1.0 by Brian Wallace (@botnet_hunter)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wget:8154605aecfea6ca754b3151f752e9f0&#34;&gt;wget&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;bwall@research:~$ wget http://bwall.github.io/ -qO- | eh -d
bwall.github.io
twitter.com
gmail.com
github.com
README.md
ajax.googleapis.com
crypto-js.googlecode.com
google-analytics.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;malware:8154605aecfea6ca754b3151f752e9f0&#34;&gt;malware&lt;/h2&gt;

&lt;p&gt;The 0686429b86844d9d1a14a159a0263b9bfcea4fd247c77537aa0278c9c5cb4ac3 file is a sample of the POS malware, Dexter, created for demo purposes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bwall@research:~$ eh 0686429b86844d9d1a14a159a0263b9bfcea4fd247c77537aa0278c9c5cb4ac3
houseofcarders.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;file-system-recursion:8154605aecfea6ca754b3151f752e9f0&#34;&gt;File system recursion&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;bwall@research:~$ eh -drf Downloads/PEStudio/
/home/bwall/Downloads/PEStudio/PeStudioFunctionsDeprecated.xml  www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioFunctionsDeprecated.xml  msdn.microsoft.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListFunctions.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioEvasions.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioIndicators.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/ChangeLog.txt    winitor.com
/home/bwall/Downloads/PEStudio/ChangeLog.txt    www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioThresholds.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioWhiteListSections.xml    www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListLibraries.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioOrdinals.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioVirusTotal.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioCodePages.xml    www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioCodePages.xml    msdn.microsoft.com
/home/bwall/Downloads/PEStudio/PeStudioWhiteListLibraries.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioFeatures.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudio.exe 6.0.0.0
/home/bwall/Downloads/PEStudio/PeStudioSettings.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml internetmailru.cdnmail.ru
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml sputnik.mail.ru
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml mail.ru
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml Command.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml 127.0.0.1
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml 2.0.0.1
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml www.memtest86.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml boxedapp.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml PAYPAL.COM
/home/bwall/Downloads/PEStudio/PeStudioBlackListStrings.xml start.spoon.net
/home/bwall/Downloads/PEStudio/PeStudioFunctionsUndocumented.xml    www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioWellKnownResources.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioFunctionsMapping.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeParser.dll 776::06
/home/bwall/Downloads/PEStudio/PeParser.dll ::
/home/bwall/Downloads/PEStudio/PeParser.dll 3::
/home/bwall/Downloads/PEStudio/PeStudioTranslations.xml www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListLanguages.xml   www.winitor.com
/home/bwall/Downloads/PEStudio/PeStudioBlackListLanguages.xml   msdn.microsoft.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;change-log:8154605aecfea6ca754b3151f752e9f0&#34;&gt;Change log&lt;/h1&gt;

&lt;h2 id=&#34;version-1-1-0:8154605aecfea6ca754b3151f752e9f0&#34;&gt;Version 1.1.0&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Files are no longer loaded completely into RAM so larger files can be processed (performance increase noticed)&lt;/li&gt;
&lt;li&gt;Strict mode added, where domains are only considered if all lower case&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;todo:8154605aecfea6ca754b3151f752e9f0&#34;&gt;TODO&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;IPv6 regex needs to be shorted and heavily tested&lt;/li&gt;
&lt;li&gt;Heavier testing&lt;/li&gt;
&lt;li&gt;Improve performance&lt;/li&gt;
&lt;li&gt;Multiple core processing support&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>